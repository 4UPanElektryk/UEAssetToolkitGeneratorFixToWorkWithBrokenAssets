using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using UAssetAPI;
using UAssetAPI.FieldTypes;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.PropertyTypes;
using UAssetAPI.StructTypes;
using static CookedAssetSerializer.KismetExpressionSerializer;
using static CookedAssetSerializer.Utils;

namespace CookedAssetSerializer {
    public static class SerializationUtils {
        public static JArray SerializeScript(FunctionExport function) {
            var jscript = new JArray();
            var index = 0;
            foreach (var instruction in function.ScriptBytecode)
                jscript.Add(SerializeExpression(instruction, ref index, true));

            return jscript;
        }

        public static void CollectGeneratedVariables(ClassExport mainobject) {
            //Collect variable names generated by SCS components
            if (FindPropertyData(mainobject, "SimpleConstructionScript", out var scs))
                if (FindPropertyData(((ObjectPropertyData)scs).Value, "AllNodes", out var allnodes)) {
                    var nodes = (ArrayPropertyData)allnodes;
                    foreach (var propertyData in nodes.Value) {
                        var node = (ObjectPropertyData)propertyData;
                        if (FindPropertyData(node.Value, "InternalVariableName", out var property))
                            GeneratedVariables.Add(property.ToString());
                    }
                }


            //Collect variables generated by timelines
            if (FindPropertyData(mainobject, "Timelines", out var _timelines)) {
                var timelines = (ArrayPropertyData)_timelines;
                foreach (var propertyData in timelines.Value) {
                    var timeline = (ObjectPropertyData)propertyData;
                    var timelineIndex = timeline.Value.Index - 1;
                    var timelineExport = (NormalExport)Exports[timelineIndex];
                    if (FindPropertyData(timelineExport, "VariableName", out var _name))
                        GeneratedVariables.Add(((NamePropertyData)_name).Value.ToName());
                    if (FindPropertyData(timelineExport, "DirectionPropertyName", out var _dname))
                        GeneratedVariables.Add(((NamePropertyData)_dname).Value.ToName());
                    if (FindPropertyData(timelineExport, "FloatTracks", out var _floatTracks)) {
                        var floatTracks = (ArrayPropertyData)_floatTracks;
                        foreach (var propertyData1 in floatTracks.Value) {
                            var floatTrack = (StructPropertyData)propertyData1;
                            if (FindPropertyData(floatTrack.Value, "PropertyName", out PropertyData _pname))
                                GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                        }
                    }

                    if (FindPropertyData(timelineExport, "VectorTracks", out _floatTracks)) {
                        var floatTracks = (ArrayPropertyData)_floatTracks;
                        foreach (var propertyData1 in floatTracks.Value) {
                            var floatTrack = (StructPropertyData)propertyData1;
                            if (FindPropertyData(floatTrack.Value, "PropertyName", out PropertyData _pname))
                                GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                        }
                    }

                    if (FindPropertyData(timelineExport, "LinearColorTracks", out _floatTracks)) {
                        var floatTracks = (ArrayPropertyData)_floatTracks;
                        foreach (var propertyData1 in floatTracks.Value) {
                            var floatTrack = (StructPropertyData)propertyData1;
                            if (FindPropertyData(floatTrack.Value, "PropertyName", out PropertyData _pname))
                                GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                        }
                    }
                }
            }

            if (Asset.assetType == EAssetType.WidgetBlueprint) {
                //Also append widget tree generated variables
                if (FindPropertyData(mainobject, "WidgetTree", out var _wtree)) {
                    var wTree = (ObjectPropertyData)_wtree;

                    if (wTree.Value.Index > 0 && Exports[wTree.Value.Index - 1] is NormalExport widgetTree)
                        if (FindPropertyData(widgetTree, "RootWidget", out var _root)) {
                            var root = (ObjectPropertyData)_root;
                            GetAllWidgets(root);
                        }
                }

                if (FindPropertyData(mainobject, "Bindings", out var _bindings)) {
                    var bindings = (ArrayPropertyData)_bindings;
                    foreach (var propertyData in bindings.Value) {
                        var binding = (StructPropertyData)propertyData;
                        if (FindPropertyData(binding.Value, "ObjectName", out PropertyData _objname))
                            GeneratedVariables.Add(((StrPropertyData)_objname).Value.ToString());
                    }
                    //PrintOutput("bindings "+asset.FilePath);
                }

                //if (FindPropertyData(mainobject, "NamedSlots", out PropertyData _namedslots)) {
                //	ArrayPropertyData namedslots = (ArrayPropertyData)_namedslots;
                //	foreach (NamePropertyData nameslot in namedslots.Value) {
                //		GeneratedVariables.Add(nameslot.Value.ToName());
                //	}
                //	//PrintOutput("namedslots " + asset.FilePath);
                //}

                ////Also append animations, they always have backing variables too
                if (FindPropertyData(mainobject, "Animations", out var _animations)) {
                    var animations = (ArrayPropertyData)_animations;
                    foreach (var propertyData in animations.Value) {
                        var animation = (ObjectPropertyData)propertyData;
                        if (animation.Value.Index <= 0) continue;
                        var animName = animation.Value.ToExport(Asset).ObjectName.ToName();
                        if (animName.EndsWith("_INST"))
                            GeneratedVariables.Add(animName.Substring(0, animName.Length - 5));
                    }
                }
            }
        }

        public static List<string> VariableWidgets = new() {
            "Button",
            "CheckBox",
            "CircularThrobber",
            "ComboBoxString",
            "DetailsView",
            "DynamicEntryBox",
            "EditableText",
            "EditableTextBox",
            "ExpandableArea",
            "Image",
            "InputKeySelector",
            "InvalidationBox",
            "ListView",
            "MenuAnchor",
            "MultiLineEditableText",
            "MultiLineEditableTextBox",
            "NamedSlot",
            "ProgressBar",
            "RetainerBox",
            "RichTextBlock",
            "RichTextSizable",
            "RichTextStylable",
            "SafeZone",
            "SinglePropertyView",
            "Slider",
            "SpinBox",
            "Synth2DSlider",
            "SynthKnob",
            "Throbber",
            "TileView",
            "TreeView",
            "WebBrowser",
            "WidgetSwitcher"
        };

        public static void GetAllWidgets(ObjectPropertyData refToWidget) {
            var isVariable = false;
            if (refToWidget.Value.Index <= 0 || Exports[refToWidget.Value.Index - 1] is not NormalExport widget) return;
            if (FindPropertyData(widget, "bIsVariable", out var _bisvariable)) {
                var bIsVariable = (BoolPropertyData)_bisvariable;
                isVariable = bIsVariable.Value;
            } else {
                if (widget.ClassIndex.IsImport()) {
                    var baseclass = widget.ClassIndex.ToImport(Asset);
                    if (baseclass.ClassName.ToName() == "Class" &&
                        VariableWidgets.Contains(baseclass.ObjectName.ToName())) isVariable = true;
                    if (baseclass.ClassName.ToName() == "WidgetBlueprintGeneratedClass") isVariable = true;
                }
            }

            if (isVariable) GeneratedVariables.Add(widget.ObjectName.ToName());

            if (!FindPropertyData(widget, "Slots", out var _slots)) return;
            var slots = (ArrayPropertyData)_slots;
            foreach (var propertyData in slots.Value) {
                var slot = (ObjectPropertyData)propertyData;
                if (!slot.Value.IsExport() || Exports[slot.Value.Index - 1] is not NormalExport child) continue;
                if (FindPropertyData(child, "Content", out var content))
                    GetAllWidgets((ObjectPropertyData)content);
            }
        }


        public static JArray SerializeScript(KismetExpression[] code) {
            var jscript = new JArray();
            var index = 0;
            foreach (var instruction in code) jscript.Add(SerializeExpression(instruction, ref index, true));

            return jscript;
        }

        public static JArray SerializeInterfaces(List<SerializedInterfaceReference> interfaces) {
            var jInterfaces = new JArray();
            foreach (var iInterface in interfaces) {
                var jInterface = new JObject {
                    { "Class", Index(iInterface.Class) },
                    { "PointerOffset", iInterface.PointerOffset },
                    { "bImplementedByK2", iInterface.bImplementedByK2 }
                };
                jInterfaces.Add(jInterface);
            }

            return jInterfaces;
        }

        public static JObject SerializeFunction(FunctionExport function, bool fieldKind = true) {
            //currentfunction = function;
            var jFunc = new JObject();
            if (fieldKind) jFunc.Add("FieldKind", "Function");

            jFunc.Add("ObjectClass", Asset.Imports[Math.Abs(function.TemplateIndex.Index) - 1].ClassName.ToName());
            jFunc.Add("ObjectName", function.ObjectName.ToName());
            jFunc.Add("SuperStruct", Index(function.SuperIndex.Index));
            jFunc.Add("Children", new JArray());
            var childProperties = new JArray();

            foreach (var property in function.LoadedProperties) childProperties.Add(SerializeProperty(property));
            jFunc.Add("ChildProperties", childProperties);
            jFunc.Add("Script", SerializeScript(function));
            jFunc.Add("FunctionFlags", ((uint)function.FunctionFlags).ToString());

            return jFunc;
        }

        public static JObject SerializeProperty(FProperty property, bool fieldKind = true) {
            var jProp = new JObject();
            if (fieldKind) jProp.Add("FieldKind", "Property");
            jProp.Add("ObjectClass", property.SerializedType.ToName());
            jProp.Add("ObjectName", property.Name.ToName());

            jProp.Add("ArrayDim", (byte)property.ArrayDim);
            jProp.Add("PropertyFlags", ((long)property.PropertyFlags).ToString());
            jProp.Add("RepNotifyFunc", property.RepNotifyFunc.ToName());
            jProp.Add("BlueprintReplicationCondition", (byte)property.BlueprintReplicationCondition);

            switch (property) {
                case FEnumProperty fenum: {
                    jProp.Add("Enum", Index(fenum.Enum.Index));
                    jProp.Add("UnderlyingProp", SerializeProperty(fenum.UnderlyingProp, false));
                    break;
                }
                case FArrayProperty farray: {
                    jProp.Add("Inner", SerializeProperty(farray.Inner, false));
                    break;
                }
                case FSetProperty fset: {
                    jProp.Add("ElementType", SerializeProperty(fset.ElementProp, false));
                    break;
                }
                case FMapProperty fmap: {
                    jProp.Add("KeyProp", SerializeProperty(fmap.KeyProp, false));
                    jProp.Add("ValueProp", SerializeProperty(fmap.ValueProp, false));
                    break;
                }
                case FInterfaceProperty finterface: {
                    jProp.Add("InterfaceClass", Index(finterface.InterfaceClass.Index));
                    break;
                }
                case FBoolProperty fbool: {
                    jProp.Add("BoolSize", fbool.ElementSize);
                    jProp.Add("NativeBool", fbool.NativeBool);
                    break;
                }
                case FByteProperty fbyte: {
                    jProp.Add("Enum", Index(fbyte.Enum.Index));
                    break;
                }
                case FStructProperty fstruct: {
                    jProp.Add("Struct", Index(fstruct.Struct.Index));
                    break;
                }
                case FNumericProperty fnumeric: {
                    break;
                }
                case FGenericProperty fgeneric: {
                    break;
                }
                case FSoftClassProperty fsoftclassprop: {
                    jProp.Add("MetaClass", Index(fsoftclassprop.MetaClass.Index));
                    break;
                }
                case FSoftObjectProperty fsoftobjprop: {
                    jProp.Add("PropertyClass", Index(fsoftobjprop.PropertyClass.Index));
                    break;
                }
                case FClassProperty fclassprop: {
                    jProp.Add("MetaClass", Index(fclassprop.MetaClass.Index));
                    break;
                }
                case FObjectProperty fobjprop: {
                    jProp.Add("PropertyClass", Index(fobjprop.PropertyClass.Index));
                    break;
                }
                //case FMulticastInlineDelegateProperty fmidelegate: {
                //        jprop.Add("SignatureFunction", Index(fmidelegate.SignatureFunction.Index));
                //        break; };
                //case FMulticastDelegateProperty fmdelegate: {
                //        jprop.Add("SignatureFunction", Index(fmdelegate.SignatureFunction.Index));
                //        break; };
                case FDelegateProperty fdelegate: {
                    if (fdelegate.SignatureFunction.Index > 0)
                        jProp.Add("SignatureFunction",
                            Asset.Exports[fdelegate.SignatureFunction.Index - 1].ObjectName.ToName());
                    else if (fdelegate.SignatureFunction.Index < 0)
                        jProp.Add("SignatureFunction",
                            Asset.Imports[-fdelegate.SignatureFunction.Index - 1].ObjectName.ToName());
                    else jProp.Add("SignatureFunction", -1);
                    break;
                }
            }

            return jProp;
        }

        public static JObject SerializaListOfProperties(List<PropertyData> Data, bool _struct = false) {
            if (!CheckDuplications(ref Data)) { }

            FName prev = null;
            var buffer1 = new JObject();
            var buffer2 = new JObject();

            var jPropArray = new JArray();

            foreach (var prop in Data)
                if (!DisableGeneration.Contains(prop.Name.ToName())) {
                    JProperty[] jPropValue = null;
                    if (prop.Name == prev && prop.DuplicationIndex != 0) {
                        jPropValue = SerializePropertyData(prop);
                        if (_struct) {
                            if (jPropValue.Length == 1)
                                jPropArray.Add(jPropValue[0].Value);
                            else
                                jPropArray.Add(new JObject(jPropValue));
                        } else {
                            foreach (var inprop in jPropValue) jPropArray.Add(inprop.Value);
                        }
                    } else {
                        if (jPropArray.Count > 1) {
                            buffer2.Add(prev.ToName(), jPropArray);
                            buffer1 = (JObject)buffer2.DeepClone();
                        } else {
                            buffer2 = (JObject)buffer1.DeepClone();
                        }

                        jPropArray = new JArray();
                        jPropValue = SerializePropertyData(prop);

                        if (_struct) {
                            if (jPropValue.Length == 1)
                                jPropArray.Add(jPropValue[0].Value);
                            else
                                jPropArray.Add(new JObject(jPropValue));
                        } else {
                            foreach (var inProp in jPropValue) jPropArray.Add(inProp.Value);
                        }

                        buffer1.Add(jPropValue);
                    }

                    prev = prop.Name;
                }

            if (jPropArray.Count <= 1) return buffer1;
            buffer2.Add(prev.ToName(), jPropArray);
            return buffer2;

        }

        public static JObject SerializeNormalExport(NormalExport export, int index) {
            var jExport = new JObject {
                { "ObjectIndex", index },
                { "Type", "Export" },
                { "ObjectClass", Index(export.ClassIndex.Index) },
                { "Outer", Index(export.OuterIndex.Index) },
                { "ObjectName", export.ObjectName.ToName() },
                { "ObjectFlags", (long)export.ObjectFlags }
            };

            var properties = SerializaListOfProperties(export.Data);
            properties.Add("$ReferencedObjects", JArray.FromObject(RefObjects.Distinct<int>()));
            jExport.Add("Properties", properties);

            RefObjects = new List<int>();
            return jExport;
        }


        public static JProperty[] SerializePropertyData(PropertyData property, bool withName = true) {
            var jProp = new JProperty(property.Name.ToName());

            if (DisableGeneration.Contains(property.Name.ToName())) return null;

            var res = new List<JProperty>();
            switch (property) {
                case BoolPropertyData:
                case FloatPropertyData:
                case DoublePropertyData:
                case Int8PropertyData:
                case Int16PropertyData:
                case IntPropertyData:
                case Int64PropertyData:
                case UInt16PropertyData:
                case UInt32PropertyData:
                case UInt64PropertyData:
                case GameplayTagContainerPropertyData:
                case TextPropertyData: {
                    jProp.Value = property.ToJson();
                    res.Add(jProp);
                    break;
                }
                case BytePropertyData prop: {
                    if (prop.ByteType == BytePropertyType.Long)
                        jProp.Value = Asset.GetNameReference(prop.Value).Value;
                    else
                        jProp.Value = prop.Value;
                    res.Add(jProp);
                    break;
                }

                case EnumPropertyData prop: {
                    jProp.Value = prop.Value.ToName();
                    res.Add(jProp);
                    break;
                }
                case NamePropertyData prop: {
                    jProp.Value = prop.Value.ToName();
                    res.Add(jProp);
                    break;
                }
                case InterfacePropertyData prop: {
                    jProp.Value = Index(prop.Value.Index);
                    RefObjects.Add((int)jProp.Value);
                    res.Add(jProp);
                    break;
                }
                case ObjectPropertyData prop: {
                    var index = Index(prop.Value.Index);
                    if (index == -1 && prop.Value.Index != 0) {
                        if (prop.Value.ToExport(Asset) is FunctionExport func) {
                            jProp.Value = func.ObjectName.ToName();
                            res.Add(jProp);
                        } else {
                            PrintOutput("Non valid object index" + prop.Value.Index);
                        }
                    } else {
                        jProp.Value = index;
                        RefObjects.Add(index);
                        res.Add(jProp);
                    }

                    break;
                }
                case SoftObjectPropertyData prop: {
                    jProp.Value = prop.Value.ToJson();
                    res.Add(jProp);
                    break;
                }
                case StrPropertyData prop: {
                    if (prop.Value != null) {
                        jProp.Value = prop.Value.Value;
                        res.Add(jProp);
                    }

                    break;
                }
                case MapPropertyData prop: {
                    var jValueArray = new JArray();
                    for (var j = 1; j <= prop.Value.Count; j++) {
                        var jobj = new JObject();

                        var key = SerializePropertyData(prop.Value.Keys.ElementAt(j - 1))[0];
                        var jKey = new JProperty("Key", key.Value);
                        jobj.Add(jKey);

                        key = SerializePropertyData(prop.Value.Values.ElementAt(j - 1))[0];
                        jKey = new JProperty("Value", key.Value);
                        jobj.Add(jKey);
                        jValueArray.Add(jobj);
                    }

                    jProp.Value = jValueArray;
                    res.Add(jProp);
                    break;
                }
                //case SetPropertyData prop: { break; }
                case ArrayPropertyData prop: {
                    var jValueArray = new JArray();
                    foreach (var valueElement in prop.Value) {
                        var element = SerializePropertyData(valueElement);
                        foreach (var ele in element) jValueArray.Add(ele.Value);
                    }

                    jProp.Value = jValueArray;
                    res.Add(jProp);
                    break;
                }
                case UnknownPropertyData: {
                    jProp.Value = "##NOT SERIALIZED##";
                    res.Add(jProp);
                    break;
                }
                case RawStructPropertyData: {
                    jProp.Value = "##NOT SERIALIZED##";
                    res.Add(jProp);
                    break;
                }
                case DateTimePropertyData:
                case TimespanPropertyData:
                case SmartNamePropertyData:
                case IntPointPropertyData:
                case GuidPropertyData:
                case ColorPropertyData:
                case LinearColorPropertyData:
                case RichCurveKeyPropertyData:
                case QuatPropertyData:
                case RotatorPropertyData:
                case Vector2DPropertyData:
                case Vector4PropertyData:
                case VectorPropertyData:
                case BoxPropertyData:
                case Box2DPropertyData:
                case SoftObjectPathPropertyData:
                case FontCharacterPropertyData:
                case FrameNumberPropertyData:
                case PerPlatformBoolPropertyData:
                case PerPlatformFloatPropertyData:
                case PerPlatformIntPropertyData:
                case MovieSceneFrameRangePropertyData:
                case MovieSceneTrackIdentifierPropertyData:
                case MovieSceneSequenceIDPropertyData:
                case MovieSceneEvaluationKeyPropertyData:
                case MovieSceneEvaluationFieldEntityTreePropertyData:
                case MovieSceneEventParametersPropertyData:
                case MovieSceneSubSequenceTreePropertyData:
                case MovieSceneSegmentIdentifierPropertyData:
                case MovieSceneTrackFieldDataPropertyData:
                //case MovieSceneSequenceInstanceDataPtrPropertyData:
                case MovieSceneFloatChannelPropertyData: {
                    res.AddRange(((JObject)property.ToJson()).Properties());
                    break;
                }
                case FontDataPropertyData prop: {
                    var value = new JObject();
                    var fontData = prop.Value;
                    if (fontData.bIsCooked) {
                        value.Add("FontFaceAsset", Index(fontData.LocalFontFaceAsset.Index));
                        RefObjects.Add(Index(fontData.LocalFontFaceAsset.Index));
                        value.Add("FontFilename", fontData.FontFilename != null ? fontData.FontFilename.ToString() : "");
                        value.Add("Hinting", "EFontHinting::" + fontData.Hinting);
                        value.Add("LoadingPolicy", "EFontLoadingPolicy::" + fontData.LoadingPolicy);
                        value.Add("SubFaceIndex", fontData.SubFaceIndex);
                    }

                    jProp.Value = value;
                    res.AddRange(value.Properties());
                    break;
                }
                case MovieSceneSegmentPropertyData prop: {
                    var value = new JObject {
                        { "Range", prop.Value.Range.ToJson() },
                        { "ID", prop.Value.ID.IdentifierIndex },
                        { "bAllowEmpty", prop.Value.bAllowEmpty }
                    };

                    var jimpls = new JArray();
                    foreach (var item in prop.Value.Impls) {
                        var structures = SerializaListOfProperties(item, true);
                        jimpls.Add(structures);
                    }

                    var data = new JObject();
                    value.Add("Impls", jimpls);
                    jProp.Value = value;
                    res.Add(jProp);
                    break;
                }
                case SectionEvaluationDataTreePropertyData prop: {
                    var tree = prop.Value.Tree;
                    var value = new JObject();
                    var serdata = new JObject { { "RootNode", tree.RootNode.ToJson() } };

                    var entries = new JArray();
                    var items = new JArray();
                    foreach (var entry in tree.ChildNodes.Entries) entries.Add(entry.ToJson());
                    foreach (var item in tree.ChildNodes.Items) items.Add(item.ToJson());
                    var childNodes = new JObject {
                        { "Entries", entries },
                        { "Items", items }
                    };

                    serdata.Add("ChildNodes", childNodes);

                    entries = new JArray();
                    items = new JArray();
                    foreach (var entry in tree.Data.Entries) entries.Add(entry.ToJson());

                    foreach (var item in tree.Data.Items) {
                        var structures = SerializaListOfProperties(item, true);
                        items.Add(structures);
                    }

                    var data = new JObject {
                        { "Entries", entries },
                        { "Items", items }
                    };
                    serdata.Add("Data", data);
                    value.Add("Tree", serdata);
                    jProp.Value = value;
                    res.Add(jProp);
                    break;
                }
                case StructPropertyData prop: {
                    var structures = SerializaListOfProperties(prop.Value, true);
                    jProp.Value = structures;
                    res.Add(jProp);
                    break;
                }
                case FieldPathPropertyData prop: {
                    if (prop.Value.Length == 0) {
                        jProp.Value = "##NOT SERIALIZED##";
                        res.Add(jProp);
                        break;
                    }

                    if (prop.Value.Length > 1) PrintOutput("FieldPathPropertyData Values array has more than one name");
                    jProp.Value = GetFullName(prop.ResolvedOwner.Index) + ":" + prop.Value[0].ToName();
                    res.Add(jProp);
                    break;
                }
                default: {
                    PrintOutput(property.PropertyType.ToName());
                    jProp.Value = "##NOT SERIALIZED##";
                    res.Add(jProp);
                    break;
                }

                //case MulticastDelegatePropertyData prop: { break; }
                //case ExpressionInputPropertyData prop: { break; }
                //case MaterialAttributesInputPropertyData prop: { break; }
                //case ColorMaterialInputPropertyData prop: { break; }
                //case ScalarMaterialInputPropertyData prop: { break; }
                //case ShadingModelMaterialInputPropertyData prop: { break; }
                //case VectorMaterialInputPropertyData prop: { break; }
                //case Vector2MaterialInputPropertyData prop: { break; }
                //case SkeletalMeshAreaWeightedTriangleSamplerPropertyData prop: { break; }
                //case SkeletalMeshSamplingLODBuiltDataPropertyData prop: { break; }
                //case SoftAssetPathPropertyData prop: { break; }
                //case SoftClassPathPropertyData prop: { break; }
                //case ViewTargetBlendParamsPropertyData prop: { break; }
                //case WeightedRandomSamplerPropertyData prop: { break; }
                //case DelegatePropertyData prop: {
                //	PrintOutput(prop.Name.ToName());
                //	break; }
            }

            return res.ToArray();
        }


        public static JProperty SerializeData(List<PropertyData> data, bool mainObject = true) {
            RefObjects = new List<int>();

            var jData = mainObject ? new JProperty("AssetObjectData") : new JProperty("Properties");

            var jDataValue = new JObject();
            foreach (var temp in data.Select(property => SerializePropertyData(property)).Where(temp => temp != null)) {
                jDataValue.Add(temp);
            }

            if (mainObject) {
                var hasSCS = jDataValue.Properties().Any(jProp => jProp.Name == "SimpleConstructionScript");
                if (!hasSCS) jDataValue.Add("SimpleConstructionScript", -1);
                if (Asset.assetType == EAssetType.WidgetBlueprint)
                    if (!FindPropertyData(data, "Animations", out PropertyData _animations))
                        jDataValue.Add("Animations", new JArray());
            }

            jDataValue.Add("$ReferencedObjects", JArray.FromObject(RefObjects.Distinct<int>()));
            RefObjects = new List<int>();
            jData.Value = jDataValue;

            return jData;
        }

        public static JProperty ObjectHierarchy(UAsset asset, bool fixnames = false) {
            RefObjects = new List<int>();
            var ObjHie = new JArray();
            for (var i = 1; i <= asset.Imports.Count; i++)
                if (Dict.ContainsKey(-i)) {
                    var import = asset.Imports[i - 1];
                    var jImport = new JObject {
                        { "ObjectIndex", Index(-i) },
                        { "Type", "Import" },
                        { "ClassPackage", import.ClassPackage.ToName() },
                        { "ClassName", import.ClassName.ToName() }
                    };
                    if (import.OuterIndex.Index != 0) jImport.Add("Outer", Index(import.OuterIndex.Index));
                    if (fixnames && import.OuterIndex.Index < 0 &&
                        import.OuterIndex.ToImport(asset).ClassName.ToName() == "Package") {
                        var package = import.OuterIndex.ToImport(asset).ObjectName.ToName();
                        var packageName = import.OuterIndex.ToImport(asset).ObjectName.ToName().Split("/").Last();
                        var assetName = import.ObjectName.ToName();
                        if (package.StartsWith("/Game") && packageName != assetName)
                            jImport.Add("ObjectName", packageName);
                        else
                            jImport.Add("ObjectName", assetName);
                    } else {
                        jImport.Add("ObjectName", import.ObjectName.ToName());
                    }

                    ObjHie.Add(jImport);
                }

            for (var i = 1; i <= asset.Exports.Count; i++)
                if (Dict.ContainsKey(i)) {
                    var jExport = new JObject();
                    if (i == asset.mainExport) {
                        jExport.Add("ObjectIndex", Index(i));
                        jExport.Add("Type", "Export");
                        jExport.Add("ObjectMark", "$AssetObject$");
                    } else {
                        switch (asset.Exports[i - 1]) {
                            case FunctionExport: { continue; }
                            case SoundNodeExport: { continue; }
                            case NormalExport normal: {
                                jExport = SerializeNormalExport(normal, Index(i));
                                break;
                            }
                        }
                    }

                    ObjHie.Add(jExport);
                }

            return new JProperty("ObjectHierarchy", ObjHie);
        }
    }
}
