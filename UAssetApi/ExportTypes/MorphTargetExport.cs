using System;
using System.Collections.Generic;
using UAssetAPI.PropertyTypes;
using UAssetAPI.StructTypes;

namespace UAssetAPI
{

    public struct FMorphTargetDelta {
        public FVector PositionDelta;
        public FVector TangentZDelta;
        public uint SourceIdx;

        public void Read(AssetBinaryReader reader) {
            PositionDelta = reader.ReadVector();
            //if (Ar.Ver < EUnrealEngineObjectUE4Version.MORPHTARGET_CPU_TANGENTZDELTA_FORMATCHANGE) {
            //    TangentZDelta = (FVector)Ar.Read<FDeprecatedSerializedPackedNormal>();
            //} else {
            TangentZDelta = reader.ReadVector();
            SourceIdx = reader.ReadUInt32();
        }
    }

    public struct FMorphTargetLODModel {
        /** vertex data for a single LOD morph mesh */
        public FMorphTargetDelta[] Vertices;
        /** number of original verts in the base mesh */
        public int NumBaseMeshVerts;
        /** list of sections this morph is used */
        public int[] SectionIndices;
        /** Is this LOD generated by reduction setting */
        public bool bGeneratedByEngine;

        public void Read(AssetBinaryReader reader) {

            int length = reader.ReadInt32();
            Vertices = new FMorphTargetDelta[length];
            for (int i = 0; i < length; i++) {
                Vertices[i].Read(reader);
            }
            NumBaseMeshVerts = reader.ReadInt32();
            length = reader.ReadInt32();
            SectionIndices = new int[length];
            for (int i = 0; i < length; i++) {
                SectionIndices[i] = reader.ReadInt32();
            }
            bGeneratedByEngine = reader.ReadInt32()!=0;

        }

    }


    /// <summary>
    /// Export for a skeletal mesh asset.
    /// </summary>
    public class MorphTargetExport : NormalExport
    {
        
        public FMorphTargetLODModel[] MorphLODModels;
        public MorphTargetExport(Export super) : base(super)
        {

        }

        public MorphTargetExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);
            reader.ReadInt32();


            byte GlobalStripFlags = reader.ReadByte();
            byte ClassStripFlags = reader.ReadByte();

            if (!((GlobalStripFlags & 2) != 0)) {
                int length = reader.ReadInt32();
                MorphLODModels = new FMorphTargetLODModel[length];
                for (int i = 0; i < length; i++) {
                    MorphLODModels[i].Read(reader);
                }


            } else {
                throw new NotImplementedException("ExistingMarkerNames not implemented");
            }



            //CollisionDisableTable = new Dictionary<FRigidBodyIndexPair, bool>();

            //int numEntries = reader.ReadInt32();
            //for (int i = 0; i < numEntries; i++)
            //{
            //    CollisionDisableTable.Add(new FRigidBodyIndexPair(reader.ReadInt32(), reader.ReadInt32()), reader.ReadInt32() != 0);
            //}
        }

        public override void Write(AssetBinaryWriter writer) {
            base.Write(writer);

            writer.Write((int)0);

        }
    }
}
